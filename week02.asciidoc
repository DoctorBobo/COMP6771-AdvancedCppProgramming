COMP6771 Advanced C++ Programming week 2 tutorial notes
=======================================================
:Author: Christopher Di Bella
:Email: cjdb.ns@gmail.com
:Date: 2016/08/03
:Revision: 1
:cpp: C++

== Admin
=== Contact
* You can contact me at {Email}.
* Please put your subject as "COMP6771 -- <subject>". I get asked a lot of {cpp} questions, and I need
  to prioritise _your_ questions over the general public's.
* Please email staff as soon as you have a question so that you don't forget to ask.
* There is also an official course forum at http://www.cse.unsw.edu.au/~cs6771. Please use this to
  ask questions that might benefit the class over both email (personal stuff exempt) and the Facbook
  group.

=== Tutorial attendance
* Not compulsory.
* We like to keep attendance for book-keeping purposes.
   * This will help us determine the correlation between attendance and marks.
* Except in **grievous circumstances**, poor tutorial attendance is likely to hurt your chances for
  an extension.
* Bjarne Stroustrup, the original creator of {cpp} strongly recommends that {cpp} beginners invest 15+
  hours per week into learning about {cpp}. Four of these hours have been reserved for you in the form
  of lectures and tutorials. Please take advantage of this!

=== {cpp}11 and {cpp}14
* {cpp}11 was a major change for {cpp}
* {cpp}14 is essentially a finished version of {cpp}11, and is only a minor change
* Some students are concerned about the textbook only containing {cpp}11 material, and the
  examinable content.
* Jingling has told me this:

"I made a brief comment in the course outline. {cpp}14 is a small improvement over {cpp}11 with minor
features introduced. You can tell students that the exam will focus on the core of {cpp}."

=== Feedback
* link:https://www.quora.com/Why-do-a-lot-of-people-seem-to-dislike-C%2B%2B/answer/Christopher-Di-Bella?srid=CbmP[One reason people dislike {cpp}] is because they have a bad experience with it.
* Another reason is because they haven't been properly educated on {cpp}.
* If you find yourself struggling in this course, please ask for help.
* You pay the university a lot of money to take this course, and if it isn't working for you, you
  have the right to let us know.
* Perhaps we can alter our teaching style a little, or find a new reference so that you can learn
  better.
* We know a lot about {cpp}, but we don't know everything about {cpp} at all times.
* There's a lot of {cpp} that I can easily look up, but don't care about in my day-to-day
  programming. Some of it is just for compiler developers/library writers.
* We might occasionally make mistakes. If you spot one, please point it out.

=== References and plagiarism
* I am against any form of academic misconduct.
* I tow a very hard line on plagiarism.
* I do my best to provide citations, or acknowledge authors wherever possible.
* I might slip up in these notes: if you spot something, please let me know, as my source will
  often provide more insight than I can.

== Resources
=== Books
* The official course textbook is link:http://amzn.to/2asmqFr[C++ Primer (5th Edition)].
* I strongly recommend that _all students_ purchase a copy of link:http://amzn.to/2au6ArE[A Tour of {cpp}].
  This book is written by Stroustrup, and is only 200 pages long (you can literally read it in an
  afternoon). It presents you with an extremely high overview of {cpp} that will make diving into
  lectures, tutorials, and assignments much easier. I recommend that you read this book once before
  each assignment and once again before the exam.
* I also recommend Stroustrup's beginner textbook, link:http://amzn.to/2aB2G1H[Programming: Principles and Practice Using {cpp} (2nd Edition)].

[CAUTION]
=========
Generally speaking, the quality of {cpp} books is _abhorrent_. If you are after a {cpp} book, please
confirm that it is on the peer-reviewed StackOverflow link:http://bit.ly/1hOS1iB[Definitive Book Guide and List].
=========

[TIP]
=====
* I am a fan of works by Bjarne Stroustrup, Herb Sutter, Scott Meyers, Anthony Williams, and Sergey
  Zubkov.
* Bjarne Stroustrup is the original creator of {cpp}. He is a senior member of WG21.
* Herb Sutter is a very senior member of the {cpp} community, and is the convener for WG21.
* Scott Meyers is a retired, but senior member of the {cpp} community. He is directly responsible for
  the programming style of a large portion of the {cpp} community.
* Anthony Williams is a concurrency expert and a senior member of the {cpp} community.
* Sergey Zubkov is a senior member of the {cpp} community, and also works directly with Stroustrup.
  He is a member of WG21, and is a _major_ contributor to en.cppreference.com (see below). He also
  has a link:https://www.quora.com/profile/Sergey-Zubkov-1[Quora.com]

* WG21 is the name of the team of people that ultimately decide what features go into the next
  version of {cpp}. WG stands for 'Working Group'.
* SG14 is a Study Group underneath WG21, led by Patrice Roy, concerned with {cpp} for games and
  finance. I am a passive member of SG14 at present.
=====

=== Websites
* link:en.cppreference.com[en.cppreference.com] -- the best {cpp} reference you can find without buying Stroustrup's
  link:http://amzn.to/2ahE2Xo[The {cpp} Programming Langauge (4th Edition)].
* link:http://isocpp.org[The official ISO {cpp} homepage]
* link:http://isocpp.org/faq[A combination of Stroustrup's original FAQ and another popular FAQ]
* link:http://stroustrup.com/[Stroustrup's Homepage]
* http://stroustrup.com/bs_faq.html
* http://stroustrup.com/bs_faq2.html
* link:http://stroustrup.com/C++11FAQ.html[Stroustrup's FAQ for {cpp}11]
* link:https://herbsutter.com/[Herb Sutter's homepage]
* link:https://herbsutter.com/gotw/[Sutter's problems page] (very insightful, and laid the
  foundations for his book series)
* link:http://stackoverflow.com/questions/tagged/c%2b%2b-faq?sort=votes[StackOverflow {cpp} FAQ]
* link:http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list[The Definitive {cpp} Book Guide and List]
* link:https://www.quora.com/profile/Christopher-Di-Bella[My Quora.com profile] (yes, I'm tooting
  my own horn a bit here, but you might find it useful)

=== Style guides
* There is no course-endorsed C++ style guide.
* My personal favourite is the link:http://bit.ly/1YnLJv7[CppCoreGuidelines].
* My tutorials will reference these guidelines a _lot_.
* The guidelines were started by Stroustrup and Sutter, and many extremely senior {cpp} programmers
  contribute to these guidelines.
* I am not a fan of the Google {cpp} Style Guide. It is highly restrictive, and limits the potential
  of {cpp} to something similar of a C-subset or Java-subset of {cpp}.
* I don't like hard-and-fast rules, but I do advocate a _few_.

== Content
=== {cpp} is not _C with Classes_.
* It is much more than _C with Classes_, as you will learn throughout the course.
* You cannot think of {cpp} as a superset of C.
* Many C programs do not compile with a {cpp} compiler.
* Some C programs that do compile with a {cpp} compiler will give you different output to when they
  are compiled on a C compiler, despite being identical source!

=== {cpp} is not _Java with low level stuff_
* link:http://stroustrup.com/bs_faq.html#Java[See Stroustrup's answer on this.]
* Don't try to program {cpp} in the same style as Java: you will do very poorly in this course.
* You will also never take advantage of {cpp}'s potential.

=== `main`
* _Must_ adhere to one of these forms:
[source,cpp]
------------
int main() { }
int main(int argc, char* argv[]) { }
int main(int argc, char* argv[], /* other parameters */) { }
------------

* Return type must be `int`. Anything else should be rejected by the compiler, as it is _not_ a {cpp}
  program.
* You cannot call `main`.
* `main` cannot be `static`, `inline`, or `constexpr`.

[TIP]
=====
`main` is a special function that does not require a `return` statement.
If your program reaches the end of `main` and doesn't execute a `return` statement, it implicitly
returns 0.

I liken this to a POSIX program: if there isn't a problem, no need to signal anything; if there _is_
a problem, then return a non-zero value.
=====

Reference: http://en.cppreference.com/w/cpp/language/main_function

=== Types
* A declaration is like an announcement to the compiler, saying "this exists!"
* A definition is actually telling the compiler about the object/function/type
* Prefer to use `{}` over `=` when initialising things. For example:
[source,cpp]
------------
int foo{ 10 };    // do this
int bar = 10;     // don't do this
int fizz = 10.5;  // fizz is actually 10
int buzz{ 10.5 }; // compiler error: trying to put a double in an int
------------

* Better yet, use `auto` on the left-hand-side. Then you just need to worry about the
  right-hand-side.
* You _need_ to use `=` with `auto`, and you _need_ to initialise your variables.
[source,cpp]
------------
auto foo = 10;   // foo is an int
auto bar = 10.5; // bar is a double
auto fizz = 10U; // fizz is an unsigned int
auto buzz;       // error: you forgot to initialise your variable
------------

. Further reading
[TIP]
=====
https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/
https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/
https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/
https://www.youtube.com/watch?v=xnqTKD8uD64&feature=youtu.be&t=28m24s
=====

==== References
* A reference is an alias for an object.
* If you assign a value to a reference, you're in fact assigning it to the object it refers to.
* You can't change what a reference refers to. It refers to what it is initialised with.
* We do this to create a reference:
[source,cpp]
------------
auto foo = 10;
auto bar& = foo;

std::cout << foo << ' ' << bar << '\n';
++foo;
std::cout << foo << ' ' << bar << '\n';
++bar;
std::cout << foo << ' ' << bar << '\n';
------------

* A `const` reference refers to an object whose value can't be changed.
* By putting the `const` there, you are promising that you won't modify the referred object via the
  reference (but you can via other means).
[source,cpp]
------------
auto foo = 10;
const auto& bar = foo;

std::cout << foo << ' ' << bar << '\n';
foo = 20;
std::cout << foo << ' ' << bar << '\n';
bar = 300; // error: can't write to a const reference.
------------

==== Pointers
* A pointer is an object that 'points' to another object.
* A pointer is like a reference, but you can change what it points to.
* `nullptr` means that the pointer doesn't point to anything.
* Prefer references unless you need to change what is being referred to, or you need a `nullptr`.
* When you want to access the object that is being referred to, we dereference the pointer.
* Dereferencing a `nullptr` is undefined behaviour.
* When assigning a pointer, you need to make sure that the types match up.
[source,cpp]
------------
auto* foo = nullptr; // this isn't pointing to anything.
auto pi = 3.1415;
foo = &pi; // foo now points to pi's location in memory

std::cout << foo << ' ' << pi << '\n'; // prints out foo's location in memory
std::cout << *foo << ' ' << pi << '\n'; // *foo is the same as pi, and is like a reference.
*foo = 3.141592; // changing pi through foo
std::cout << foo << ' ' << pi << '\n';
std::cout << *foo << ' ' << pi << '\n';

auto bar e = 2.8;
foo = &e; // foo now points to e's memory location and has nothing to do with pi
std::cout << foo << ' ' << e << ' ' << pi << '\n';
std::cout << *foo << ' ' << e << ' ' << pi <<'\n';
------------

* There's two types of pointer: `const` pointers, and pointer to `const`.
* A `const` pointer is a pointer that can only point to one thing, like a reference can only
  reference one thing.
* A pointer to `const` is a pointer that can point to anything at any time, but you can't change the
  value that is pointed to when you dereference the pointer.
[source,cpp]
------------
auto pi = 3.14;
auto* const foo = &pi;
*foo = 3.1415; // ok
foo = nullptr; // error: foo is a const pointer and cannot be changed

const auto* bar = &pi; // bar is the pointer, pi is the pointee
*bar = 3.141592; // error: bar is a pointer-to-const, so you cannot change the pointee
bar = nullptr; // ok

const auto* const fizz = &pi;
*fizz = 3.141592; // error: fizz is a pointer-to-const, so you cannot change the pointee
fizz = nullptr; // error: fizz is a const pointer and cannot be changed
------------

=== Streams
* `<<` is the put-to operator, and is associated with output.
* `>>` is the get-from operator, and is associated with input.

==== `iostream`
* `cout` is the character output stream.
* `cerr` is the character error stream.

[CAUTION]
=========
* Many students asked why I choose to use `'\n'` over `endl` in tutorials.
* They pointed out that `endl` is a platform-independent version of `'\n'`, and becomes `"\r\n"` on
  Windows systems, and `'\n'` on Unix systems such as Linux.
* Many textbooks and online sources state this, but it isn't correct.
* `endl` does two things: it puts `'\n'` to the output/error stream, and then flushes the buffer.
* Flushing a buffer is slow, so your program might suffer a performance hit.
* If you're sceptical, take a look through any of the textbooks I mentioned above.
* The CppCoreGuidelines recommend against using `endl` unless you _need_ to print `'\n'` and then
  flush the buffer.
* If you _really_ need to flush frequently, consider `cerr` or `unitbuf` in real-world programs.
  I am not sure if this will work for COMP6771 assignments or if output put to `cerr` is ignored.
* Provided that you understand the first four points, these are not hard-and-fast rules, but my
  recommendations, based off more experienced {cpp} programmers (e.g. Stroustrup, Sutter, Zubkov,
  etc.)
* The following code examples all do the same thing:
[source,cpp]
------------
// example 1
std::cout << "Hello, world!" << std::endl;

// example 2
std::cout << "Hello, world!\n" << std::flush;

// example 3
std::cout << "Hello, world!\n";
std::cout.flush();

// example 4
std::cout << "Hello, world!";
std::cout.put('\n');
std::cout.flush();
------------
=========

* `cin` is the character input stream.

[CAUTION]
=========
* When getting input from `cin`, you need to check whether or not the input is properly formatted.
* Compile and run the the program below, and try entering the input `a 12345`:

[source,cpp]
------------
#include <iostream>

int main()
{
   std::cout << "Enter two unsigned ints:\n";
   auto a = 0U;
   auto b = 0U;
   std::cin >> a >> b;
   std::cout << "a == " << a << "; b == " << b << '\n';
}
------------

* Because you didn't check that the input was good, your program didn't know what to do.
* The results are probably _very_ interesting.
* Now do the same thing with this program:
[source,cpp]
------------
#include <iostream>
#include <limits>

int main()
{
   std::cout << "Enter two unsigned ints:\n"
   auto a = 0U;
   auto b = 0U;

   // keep trying to get input until the correct type of input is put in
   while (!(std::cin >> a >> b))
   {
      std::cerr << "Whoops! Please enter two whole numbers >= 0.\n";
      std::cout << "Enter two unsigned ints:\n";

      // clear the error flags
      std::cin.clear();

      // ignore everything until the first new line in the buffer
      std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
   }

   std::cout << "a == " << a << "; b == " << b << '\n';
}
------------
=========

===== References
* Working Draft, Standard for Programming Language {cpp}, p.1051 (final {cpp}14 draft)
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#slio50-avoid-endl[CppCoreGuidelines: Avoid `endl`]
* link:https://www.quora.com/Why-is-endl-preferred-over-n-sequence-in-C%2B%2B/answer/Sergey-Zubkov-1?srid=CbmP&share=527eb8ca[Why is `endl` preferred over `'\n'` sequence? -- Quora.com]
* link:https://www.youtube.com/watch?v=GMqQOEZYVJQ[{cpp} Weekly ep 7: Stop using `std::endl`]
* link:http://en.cppreference.com/w/cpp/io/manip/endl[en.cppreference.com on `endl`]
* link:http://stackoverflow.com/questions/213907/c-stdendl-vs-n[StackOverflow post on `'\n'` and `endl`]

==== `fstream`
* `ofstream` is for file output.
* `ifstream` is for file input.
* `fstream` is for file input and file output on the _same_ file at the _same_ time. Don't use this
  unless you need to perform both input and output on the same file.
   - Anything applicable to `ifstream` is also applicable to `fstream`
   - Anything applicable to `ofstream` is also applicable to `fstream`
* Using file streams is the same as when you use `cout` and `cin`.
[CAUTION]
=========
* Many sources incorrectly inform you to use `ifstream::eof` when reading in from file.
* `eof` is just an indicator
* This is the correct way to handle file input:
[source,cpp]
------------
#include <iostream>
#include <fstream>

int main()
{
   auto infile = std::ifstream{ "foo" };
   if (!infile)
   {
      std::cerr << "File opening failed\n";
      return 1;
   }

   // we use a for-statement, because we don't need to use the variable `a`
   // after we finish reading in the file!
   for (auto a = 0; infile >> a; )
      std::cout << a << '\n';

   if (infile.eof())
   {
      std::cout << "End of file reached successfully\n";
   }
   else if (infile.bad())
   {
      std::err << "I/O error while reading\n";
      return 2;
   }
   else if (file.fail())
   {
      std::err << "Non-integer data encountered\n";
      return 3;
   }
}
------------

.Reference
****
* Author: Sergey Zubkov
* Source: https://www.quora.com/What-is-the-the-function-of-eof-in-c%2B%2B/answer/Sergey-Zubkov-1?srid=CbmP
* I modified the code to suit the style of code I teach. This is a demonstration of what _verbatim
  plagiarism_ looks like.
* **Do not plagiarise others' work.**
****
=========

=== RAII
* Notice how Sergey didn't close the file, and I didn't bother to add it in for him to suit my
  style.
* This is an example of Resource Acquisition is Initialisation (RAII for short).
* RAII is essentially an object cleaning up after itself when you are finished with it.
* "Finished" means the object has been destroyed:
   - The end of the expression for a temporary (an object without a name, such as a string literal)
   - A local variable gone out of scope
   - Deleting (freeing) an object on the heap
   - Leaving the program (for `static` varaibles)
   - We will cover object lifetime throughout the course, so don't panic if you don't get it yet.
   - Source: http://en.cppreference.com/w/cpp/language/lifetime
* RAII is not like garbage collection
   - RAII is a programming _idiom_; garbage collection is a fire-and-forget tool.
   - RAII requires you to allocate resources and clean up after yourself
   - When using RAII correctly, you are guaranteed to have the clean up when the object is
     destroyed. Garbage collection makes no such guarantee.
   - Source 1: http://en.cppreference.com/w/cpp/language/raii
   - Source 2: http://stackoverflow.com/questions/8712666/when-has-raii-an-advantage-over-gc
* When the `ifstream` object goes out of scope, the file will automatically be closed.
* An `ofstream` file will flush the stream and then close.
* If you're uncomfortable about the above, you can consider this program instead:
[source,cpp]
------------
#include <iostream>
#include <fstream>

int main()
{
   if (auto infile = std::ifstream{ "foo" })
   {
      for (auto a = 0; infile >> a; )
         std::cout << a << '\n';

      if (infile.eof())
      {
         std::cout << "End of file reached successfully\n";
      }
      else if (infile.bad())
      {
         std::err << "I/O error while reading\n";
         return 2;
      }
      else if (file.fail())
      {
         std::err << "Non-integer data encountered\n";
         return 3;
      }
   }
   else
   {
      std::cerr << "File opening failed\n";
      return 1;
   } // file closed here, where the if-statement is finished.
}
------------

.Reference
[CAUTION]
=========
* Author: Sergey Zubkov
* Source: https://www.quora.com/What-is-the-the-function-of-eof-in-c%2B%2B/answer/Sergey-Zubkov-1?srid=CbmP
* I modified the code to suit the style of code I teach. This is a demonstration of what _derived
  plagiarism_ looks like.
* **Do not do plagiarise others' work.**
=========

* I actually recommend this one. The original example was just for motivation about RAII.
* When we get to the end of the outer `if`-statement, the file is automatically closed.
* We generally like to keep objects as local as possible, which is why I've used a `for`-loop
  instead of a `while`-loop.

==== `sstream`
* `istringstream` is for converting values in text to types (e.g. `"42"` to `42`)
* `ostringstream` is for converting objects to values in strings (e.g. `42` to `"42"`)
* `stringstream` is for both `istringstream` operations and `ostringstream` operations.
* The same rules apply to the `sstream` objects as `iostream` and `fstream` objects.
