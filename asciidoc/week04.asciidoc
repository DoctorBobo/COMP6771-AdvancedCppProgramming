Week 4 tutorial postscript
==========================
:Author: Christopher Di Bella
:Email: cjdb.ns@gmail.com
:Revision: 1
:Date:
:cpp: C++

== Some important terms
* These should have been in the first postscript notes.
* These terms are _probably_ not directly assessable, but their implications are.
   - That means that you _probably_ won't be asked to define them in the final exam, but
     understanding them is critical to writing good software in {cpp}.

=== Implementation-defined behaviour
* Behaviour that depends on the implementation for all well-formed programs with correct data.
* The implementation (compiler) is required to document implementation-defined behaviour.
* Some examples of implementation-defined behaviour include:
   - the size of fundamental types (excluding `char`, `unsigned char`, and `signed char`),
   - type of `std::size_t`,
   - parameters to `main`,
   - whether or not `char` is signed,
   - lots more...

* You can think of this like the oil required for a car:
   - Each car requires oil
   - Some cars have require a different grade of oil to other cars
   - The car manufacturer tells you which types of oil your car can use

=== Unspecified behaviour
* Exactly the same as implementation-defined behaviour, except:
   - The implementation is _not_ required to document the behaviour that occurs, and
   - The range of possible behaviours is often dictated by the standard.
* Examples of unspecified behaviour include:
   - the order in which an expression is evaluated for two expressions that are not sequenced
   - whether or not a reference requires storage
   - the order in which function arguments are evaluated
* Unspecified behaviour is similar to a police officer's threshold for speeding:
   - They have a threshold, and it could be `speed_limit * 1.1 + 3`
   - Another officer's threshold might be `speed_limit * 1.1`
   - They aren't required to tell you what their threshold is.

=== Undefined behaviour
* The standard imposes no restrictions on what the program is allowed to do.
* Your program could:
   - do nothing,
   - loop indefinitely and then terminate when it 'feels' like it,
   - terminate immediately,
   - randomly delete files,
   - launch nuclear missiles,
   - create a wormhole that transports you, and only you, to Andromeda,
   - or anything else
* There is no "but the program will usually do..." when it comes to undefined behaviour.
* The compiler isn't required to alert you to the fact you might permit undefined behaviour in your
  program.
* Some examples of undefined behaviour include:
   - accessing memory outside of the bounds of an array
   - letting a signed integer overflow or underflow
   - dereferencing a null pointer,
   - writing to the same scalar more than once in the same expression without sequencing,
   - deleting an object twice,
   - returning a reference to a local object,
   - race conditions,
   - deadlocks,
   - much, much more...
* A program that allows undefined behaviour is undefined at all points in the program: from the
  very beginning until the very end.

.Why?
[source,cpp]
------------
#include <limits>
#include <random>

int bomb()
{
   auto generator = std::mt19937{std::random_device{}()};
   auto distribute = std::uniform_int_distribution<>{std::numeric_limits<int>::min(), std::numeric_limits<int>::max()};

   auto tick = 0;
   for (auto i = generator(); i != 0; ++tick)
      ++i;
}
------------

* Can you predict when or even _if_ `i` is going to overflow?
   - No, the PRNG makes it impossible to predict.
   - This entire function is thus undefined.
   - Therefore, the code calling `bomb` is undefined, and so on.
* Think of undefined behaviour as driving while under the influence of a _lot_ of alcohol:
   - You can't predict what's going to happen
   - You can't predict when it's going to happen
   - Sometimes you might get home safely
   - Sometimes you might crash and hurt someone (including yourself)
   - Sometimes you might crash and kill someone (including yourself)

=== What does all this mean?
* Guard against undefined behaviour.
* Never rely on unspecified behaviour.
* Code against interfaces, not against implementations.
   ** One easy way to do this is to use `auto` as much as possible.

[source,cpp]
------------
#include <iostream>

int main()
{
   int i = 10'000'000'000;
   std::cout << i << '\n';
}
------------

      *** This is a well-formed program, but is its behaviour defined?
      *** Using CSE's gcc implementation, the behaviour of this program is undefined because of the
          signed integer overflow (`sizeof(int) < sizeof(10'000'000'000)`)
      *** On a custom gcc implementation, the behaviour of this program is well-defined, since
          `sizeof(int) == sizeof(10'000'000'000)`.
      *** Don't expect the compiler to catch you on this!

[source,cpp]
------------
#include <iostream>

int main()
{
   auto i = 10'000'000'000;
   std::cout << i << '\n';
}
------------

      *** Now the behaviour is well-defined for all implementations, because we are trusting the
          compiler to do its job and work out the correct type.
   ** Another way to combat reliance on implementations is to compile your code against two or more
      compilers (e.g. gcc _and_ clang... avoid Visual {cpp} and Intel {cpp} unless necessary as they
      don't fully implement {cpp}14 just yet).
* Don't rely on the inner workings of a compiler if possible.
   ** If it isn't possible, try to localise the reliance by encapsulating it in a function that can
      easily be changed.

.References
[TIP]
=====
* ISO/IEC. Working Draft, Standard for Programming Language {cpp}, p.3 -- 4. 2014. ISO/IEC,
  Geneva Switzerland.
* Meyers, S. _Effective STL: 50 specific ways to improve your use of the standard template
  library_. p.209 -- 210. 2001. Pearson Education, Inc. Upper Saddle River, NJ.
* Meyers, S. _Effective {cpp}: 55 specific ways to improve your programs and designs_.
  Third edition. p.262 -- 263. 2005. Pearson Education, Inc. Upper Saddle River, NJ.
* Stroustrup, B. _The {cpp} programming language_. Fourth edition. p.136 -- 137. 2013.
  Pearson Education, Inc. Upper Saddle River, NJ.
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rp-Cplusplus[CppCoreGuidelines
  -- P.2: Write in ISO Standard {cpp}]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-except[CppCoreGuidelines
  -- I.10: Use exceptions to signal a failure to perform a required task]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-array[CppCoreGuidelines
  -- I.13: Do not pass an array as a single pointer]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rf-value-capture[CppCoreGuidelines
  -- F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including
  returned, stored on the heap, or passed to another thread]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-always[CppCoreGuidelines
  -- ES.20: Always initialize an object]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-order[CppCoreGuidelines
  -- ES.43: Avoid expressions with undefined order of evaluation]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-order-fct[CppCoreGuidelines
  -- ES.44: Don't depend on order of evaluation of function arguments]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-arr2[CppCoreGuidelines
  -- ES.62: Don't compare pointers into different arrays]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-overflow[CppCoreGuidelines
  -- ES.103: Don't overflow]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-underflow[CppCoreGuidelines
  -- ES.104: Don't underflow]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-zero[CppCoreGuidelines
  -- ES.105: Don't divide by zero]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro-type-constcast[CppCoreGuidelines
  -- Type.3: Don't use const_cast to cast away const (i.e., at all).]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#never-let-a-pointer-outlive-the-object-it-points-to[CppCoreGuidelines
  -- Never let a pointer outlive the object it points to]
* link:http://en.cppreference.com/w/cpp/language/ub[cppreference -- Undefined behaviour]
* link:http://en.cppreference.com/w/cpp/language/eval_order[cppreference -- Order of evaluation]
=====

== `class` and `struct`
* Allows you to define your own types.
* Support both data members and member functions.
* Declare your member functions as `const` until you have a reason not to.
* Make data members private until you have a reason not to.

.Quiz
[NOTE]
=====
1. What is the difference between class and struct?
2. What are the three access modifiers available?
3. When should you use a `struct`?
4. When should you use a `class`?
=====

.Further reading
[TIP]
=====
* Stroustrup, B. _The {cpp} programming language_ 4th Edition. p.201 -- 213, 449 -- 479. 2013.
  Pearson Education Inc. Upper Saddle River, NJ.
* Stroustrup, B. _Programming: principles and practice using {cpp}_. 2nd Edition. p.173 -- 254, 303
  -- 341. 2014. Pearson Education Inc. Upper Saddle River, NJ.
* Stroustrup, B. _A tour of {cpp}_. p.16 -- 18, 33 -- 57. 2014. Pearson Education Inc. Upper Saddle
  River, NJ.
* Sutter, H. _Exceptional {cpp} style: 40 new engineering puzzles, programming problems, and
  solutions_. p.104 -- 128. 2005. Pearson Education, Inc. Boston, MA.
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c-classes-and-class-hierarchies[CppCoreGuidelines
  -- C: Classes and Class Hierarchies]
=====

=== <<norm-ctor,Constructors>>
* A special function that does not return.
* Responsible for creating the object.
* There are three different kinds of constructor:
   - xref:norm-ctor[Constructor]
   - xref:copy-ctor[Copy constructor]
   - xref:move-ctor[Move constructor]
* If you don't need to define a copy constructor or a move constructor, _don't_ define them.
* Use member initialisers over default constructors wherever possible.

[source,cpp]
------------
class film
{
public:
   film() = default;
   film(const std::string& title,
        const std::string& director,
        const std::vector<std::string>& cast,
        std::int64_t revenue);
private:
   std::string title_{"<title-unknown>"};
   std::string director_{"<director-unknown>"};
   std::vector<std::string> cast_{};
   std::int64_t revenue_{0};
};

film::film(const std::string& title,
           const std::string& director,
           const std::vector<std::string>& cast,
           const std::int64_t revenue)
   : title_{title}, director_{director}, cast_{cast}, revenue_{revenue}
{
}
------------

.Quiz
[NOTE]
=====
1. What happens when you don't define a constructor at all?
2. What happens when you don't define a default constructor?
3. What is a delegating constructor?
4. Why is the body of the above constructor empty?
5. What is an explicit constructor?
6. When is an explicit constructor useful?
7. Why do we like explicit constructors?
8. What is a member initialiser?
=====

.References
[TIP]
=====
* Meyers, S. _Effective {cpp}: 55 specific ways to improve your programs and designs_.
  Third edition. p.34 -- 37. 2005. Pearson Education, Inc. Upper Saddle River, NJ.
* Stroustrup, B. _The {cpp} programming language_ 4th Edition. p.481 -- 484, 487 -- 488, 489
  -- 506. 2013. Pearson Education Inc. Upper Saddle River, NJ.
* Stroustrup, B. _Programming: principles and practice using {cpp}_. 2nd Edition. p.173 -- 254, 303
  -- 341. 2014. Pearson Education Inc. Upper Saddle River, NJ.
* Sutter, H. _More exceptional {cpp}: 40 new engineering puzzles, programming problems, and
  solutions_. p.115 -- 126. 2002. Pearson Education, Inc. Boston, MA.
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-ctor[CppCoreGuidelines
  -- C.40: Define a constructor if a class has an invariant]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-complete[CppCoreGuidelines
  -- C.41: A constructor should create a fully initialized object]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-throw[CppCoreGuidelines
  -- C.42: If a constructor cannot construct a valid object, throw an exception]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-default0[CppCoreGuidelines
  -- C.43: Ensure that a class has a default constructor]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-default00[CppCoreGuidelines
  -- C.44: Prefer default constructors to be simple and non-throwing]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-default[CppCoreGuidelines
  -- C.45: Don't define a default constructor that only initializes data members; use in-class
  member initializers instead]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-explicit[CppCoreGuidelines
  -- C.46: By default, declare single-argument constructors explicit]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-order[CppCoreGuidelines
  -- C.47: Define and initialize member variables in the order of member declaration]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-in-class-initializer[CppCoreGuidelines
  -- C.48: Prefer in-class initializers to member initializers in constructors for constant initializers]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-initialize[CppCoreGuidelines
  -- C.49: Prefer initialization to assignment in constructors]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-delegating[CppCoreGuidelines
  -- C.51: Use delegating constructors to represent common actions for all constructors of a class]
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-inheriting[CppCoreGuidelines
  -- C.52: Use inheriting constructors to import constructors into a derived class that does not
  need further explicit initialization]
=====

=== `const` member functions
* Promise that the function won't modify any non-`mutable` data members.
* Can only call other `const` member functions.
* Objects specified to be `const` can only call `const` member functions.

[source,cpp]
------------
class film
{
public:
   film(const std::string&, const std::string&, const std::vector<std::string>&, const std::int64_t);
   const std::string& title() const;
private:
   std::string title_;
   std::string director_;
   std::vector<std::string> cast_;
   std::int64_t revenue_;
};

film::film(const std::string& title,
           const std::string& director,
           const std::vector<std::string>& cast,
           const std::int64_t revenue);
   : title_{title},
     director_{director},
     cast_{cast},
     revenue_{revenue}
{
}

const std::string& film::title() const
{
   title_ = "Star Wars: The Empire Strikes Back"; // error: title_ is immutable in this function
   return title_; // okay
}
------------

.Quiz
[NOTE]
=====
1. How should you be returning data members by default?
2. When should you not be returning data members this way?
=====

.References
[TIP]
=====
* Meyers, S. _Effective {cpp}: 55 specific ways to improve your programs and designs_.
  Third edition. p.19 -- 26. 2005. Pearson Education, Inc. Upper Saddle River, NJ.
* Stroustrup, B. _The {cpp} programming language_ 4th Edition. p.461 -- 463. 2013. Pearson
  Education Inc. Upper Saddle River, NJ.
* Sutter, H. _Exceptional {cpp}: 47 engineering puzzles, programming problems, and solutions}_.
  p.69 -- 75, 177 -- 184. 2000. Pearson Education, Inc. Indianapolis, IN.
* link:https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rconst-fct[CppCoreGuidelines
  -- Con.2: By default, make member functions `const`]
=====

=== `mutable` data members
* The exception to the `const` rule: you can modify a `mutable` data member inside a `const`
  function.
* Sounds shady, right?
* Only very carefully chosen members should be `mutable` (e.g. a cache).

[source,cpp]
------------
class cinema
{
public:
   // ...
   const film& top_grossing_film() const;
   void push_back(const film&); // inserts film and sets top_film_ to nullptr
   void erase(const std::size_t i); // erases film and sets top_film_ to nullptr
   void clear(); // erases all films and sets top_film_ to nullptr
private:
   std::vector<film> films_;
   mutable decltype(films_)::const_pointer top_film_;
};

const film& cinema::top_grossing_film() const
{
   if (!top_film_)
   {
      top_film_ = &films_[0]; // reset top_film_ so it isn't a dangling pointer
      for (const auto& f : films_)
         top_film_ = &std::max(f, *top_film_);
      cache_invalidated_ = false;
   }

   return *top_film_;
}
------------

=== `inline` functions
* A function that is prefixed with the `inline` specifier declares an inline function, which allows
  it to be defined multiple times.
   ** Each definition must be identical (including the `inline` specifier), and
   ** the function must be defined in every file it is call.
* The most common way to enforce these two requirements is to write an inline function once in a
  header, and to simply include that header whenever you need to call the function.
* Functions that are declared inside a class body are implicitly `inline`: putting the `inline`
  specifier in front of the function signature is superfluous.
* We declare inline functions to hint to the compiler that it should replace function calls with the
  body of the function.
   ** This can potentially improve performance, as the call overhead is lost, and other
      optimisations might be possible (key word is "_might_" -- as an expert in compilers,
      Jingling can better answer this).
   ** Remember to test for performance before making performance claims.
   ** We often inline small functions, such as accessors, simple mutators, and constructors without
      bodies.
   ** Just because a function has been specified as `inline` does not mean that the compiler will
      listen to your recommendation and actually inline the function body.
* If you are concerned about revealing your implementation to clients and this breaking
  encapsulation, understand that:
   ** {cpp} encapsulation guards against mistakes, not fraud or espionage.
      *** Provided no one acts upon the encapsulated code, it doesn't really matter if they can see
          your implementation.
   ** Splitting code into headers and implementation files makes compilation easier (faster).
   ** Stick to the small functions that don't reveal too much.
* `main` may not be declared as an inline function.
* Prefer `inline` functions to `#define` macros.

[source,cpp]
------------
// An inline example
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

class book
{
public:
   book(std::istream&); // not an inline function... defined elsewhere

   const std::string& author() const { return author_; } // implicit inline function
   void author(const std::string& s) { author_ = s; }    // another implicit inline function
private:
   std::string author_;
};

// freestanding functions _need_ to be declared as inline
inline book read_file(const std::string& filename);

int main()
{
   using namespace std::literals;
   auto library = std::vector<book>{read_file("tour++.book"), read_file("pppuc++.book")};
   for (auto filename = ""s; std::cin >> filename; )
      library.push_back(read_file(filename));
}

inline book read_file(const std::string& filename)
{
   using namespace std::literals;
   if (auto in = std::ifstream{filename})
      return book{in};
   else
      throw std::runtime_error{"Cannot open file "s + filename};
}
------------

=== `friend` functions
* Have access to a class's privates.
* Are free-form functions or other classes that have the _same_ access as any function within the
  class.
* Avoid them if you can.
* Prefer non-member, non-friend functions when possible.
   - Non-member, non-friend functions help to improve encapsulation.

== Resource Acquisition is Initialisation (or as it's called in lectures, "Copy Control")
* The _single_ most powerful feature C++ has to offer.
* More important than object-oriented programming and generic programming.
* It's not just a language feature, but a programming idiom.
   1. You allocate a resource.
   2. You use the resource.
   3. You clean up the resource yourself, but the compiler decides when it happens.
   4. That's the general idea!

.What is a resource?
[options="header"]
|========================
|Example                                                                                  |Do we ned to worry about it (in modern C++)?                                                                                                                       
|A file handle.                                                                           |`ofstream` and `ifstream` already worry about cleaning up file handles, so unless you have some reason not to use them, you don't need to worry about file handles.
|An _owning_ pointer, or a pointer that is responsible for deallocating free store memory.|All owning pointers should be smart pointers where possible, so this is rarely a concern.                                                                          
|A mutex.                                                                                 |We'll cover mutexes another day, but there's stuff for them too.                                                                                                   
|Some other system-related stuff...                                                       |You'll need to inspect the standard library and GSL to see for yourself.                                                                                           
|========================

* You've been using it a lot already without knowing:
   - `vector` employs it (it dynamically allocates memory, but you never personally clean it up)
   - `ifstream` employs it (you open the file handle, but you never personally close it)

.It's not garbage collection.
[options="header"]
|=========================
|Garbage collection                                                                      |RAII                                                             
|is a fire and forget tool employed by a runtime.                                        |is a programming idiom actively employed by vigilant programmers.
|can happen at any point _from_ the end of an object's life to the program's termination.|is guaranteed to happen _at_ the end of an object's life.        
|=========================

=== Destructor, copy constructor, copy assignment, and the rule of three
* The destructor is a function that's (usually) automatically called at the end of an object's
  lifetime.
   ** If you don't define one, it'll be synthesised for you.
   ** It is responsible for cleaning up any members, but it doesn't automatically clean up resources
      that you reserve.
      *** If you reserve resources, you will need to define a destructor and manually specify how
          the resources are to be cleaned up.
   ** It is specified to be `noexcept` by default, and you shouldn't allow an exception to leave the
      destructor unless you want all kinds of trouble.
   ** Creating a destructor to clear a `vector` or set an `int` to 0 is redundant and should not be
      done.
* A copy constructor is responsible for copying resources from an object into an object that is
  being constructed.
   - If you don't define one, it'll be synthesised for you.
   - You are responsible for ensuring that resources you reserve are correctly copied.
   - Creating a copy constructor just to copy a `vector` is redundant, and shouldn't be done.
* A copy assignment operator is responsible for copying resources from an object A into a
  pre-existing object B, _and_ cleaning up the original resources in B.
   - If you don't define one, it'll be synthesised for you.
   - You are responsible for ensuring that any resources that B currently holds are appropriately
     cleaned up, and then properly copying the resources across from A.
   - Creating a copy assignment operator just to copy a `vector`, or 'ensure' that your objects have
     the same values is redundant, and shouldn't be done.

.Be aware for self-assignment
[WARNING]
=====
* If you perform `a = a;`, the state of `a` must remain the same.
* There are three copy assignment operators below, one is incorrect, one is recommended, and one
  should only be used with good reason.
[source,cpp]
------------
template <typename T>
smart_ptr<T>& smart_ptr<T>::operator=(const smart_ptr<T>& d)
{
   delete data_;
   data_ = new T{*d.data_};
   return *this;
}
------------

* What can go wrong with the above?
   - If we perform `a = a`, then we have just deleted the data we wish to copy.
   - We are also dereferencing a dangling pointer. The result of this is undefined.
   - This should be rejected by compiler warnings, lint tools, a static analysers, _and_ code
     reviews, but don't expect compiler warnings alone to stop you.
   - This is the not-recommended one.

[source,cpp]
------------
template <typename T>
smart_ptr<T>& smart_ptr<T>::operator=(const smart_ptr<T>& d)
{
   if (this != &d)
   {
      delete data_;
      data_ = new T{*d.data_};
   }

   return *this;
}
------------

* This is better, but there's still a few things to consider:
   - If we perform `a = a`, then the resources are preserved.
   - This is production-okay code.
   - This shouldn't be rejected by lint tools and static analysers, but might be rejected by a
     strict code review team.
   - The key problem is that we need to explicitly release any held resources and then allocate new
     resources, and we might forget to do it.
   - We've also already done both of these in our copy constructor and our destructor, so there's
     now some code duplication.
   - If only there were a way to reduce code duplication...

[source,cpp]
------------
template <typename T>
smart_ptr<T>& smart_ptr<T>::operator=(const smart_ptr<T>& d)
{
   auto t = smart_ptr{d}; // copy constructor call
   std::swap(*this, t);   // resources of our old smart_ptr go into t
   return *this;
} // t cleaned up here by definition
------------

* ...which we can do by invoking the copy constructor and the destructor!
   - Credit goes to Scott Meyers.
   - This is the recommended one, unless you have some reason to use the second one.
=====

* **The rule of three states that if you have a need to implement one of these, you must implement
  all of them.**
[WARNING]
=========
* There is no compiler check to see if you do or do not implement all three.
* There is also no compiler check to see if you have correctly implemented any of them.
* A static analyser may help, but do not expect it to catch everything you've missed.
* This is a part of the RAII programming idiom, and is up to you to enforce.
=========

=== Rvalue references
* We learned about _lvalue_ references in week 1.
* An lvalue reference refers to some lvalue (a function or object).
* You cannot bind an lvalue reference to an rvalue, but you may bind an lvalue reference-to-`const`
  to an rvalue.

[source,cpp]
------------
auto& reference_to_int = 0; // error: can't bind an lvalue reference to an rvalue
const auto& reference_to_const_int = 0; // okay
------------

* Rvalue references refer to rvalues.
   - Rvalue references cannot bind to lvalues.
* They may bind to temporaries, which are a form of rvalue.
   - A temporary is an object without a name.
   - A temporary is destroyed at the end of the full expression it is constructed in.
* They may also bind to lvalues that are nearing the end of their lifetime.
   - We need to explicitly tell the compiler about this, but more on this later.
* Rvalue references are used for _destructive_ reads.
   - An rvalue reference-to-`const` is thus pointless.

[source,cpp]
------------
auto&& rvalue_reference = 0; // okay
const auto&& rvalue_reference_to_const = 0; // legal, but the rvalue reference is now useless.
------------

=== Move constructor, move assignment, and the rule of five
* A fax machine scans your document and replicates it. This is akin to copying.
* Handing a document to another person means that you no longer have the document, and only one
  document is in circulation. This is akin to moving.
* Moving things happens at the near of an object's lifetime.
   - Does that sound familiar?
   - Moving works with rvalue references.
* An object that has been moved is left in a destructible state, but should not be read from.

==== Move constructors
* Move constructors are responsible for moving all of an object's resources from a preexisting
  object to an object that is just being constructed.
* The rules for a synthesised move constructor are stricter than those for a copy constructor.
  Namely, you must not have defined a custom:
   1. Copy constructor
   2. Copy assignment operator
   3. Destructor
   4. Move constructor (no point synthesising one if you already made it -- you know better than
      the compiler, after all!)
   5. Move assignment operator
* Similarly to the above, defining your own to explicitly move anything other than a resource is
     redundant.
* Similarly to all other constructors, make sure that you use your initialiser list.

[source,cpp]
------------
template <typename T>
smart_ptr<T>::smart_ptr(smart_ptr<T>&& o)
   : data_{o.data_}
{
   o.data_ = nullptr; // o.data_ is no longer an owner of the
                      // object, and cannot point to the resource.
}
------------

* If you'd like to move something other than a built-in type, you'll need to use a special function
  called `std::move`.
   - _Never_ dequalify `std::move`, not even with `using std::move`.
   - It is a very important function, and has a common name. Mixing it up with some other function
     is very, _very_ bad.

[source,cpp]
------------
template <typename T>
record<T>::record(record<T>&& o)
   : data_{std::move(o.data_)}, // data_ is a vector<T>
     resource_{o.resource_} // resource_ is a pointer pointing to something on the free store
{
   o.resource_ = nullptr;
}
------------

[TIP]
=====
* Notice that we didn't do anything with `o.data_`, like we did with `o.resource_`. This is because
  `vector` has a move constructor that does all of that for us.
   - If we weren't explicitly managing `resource_`, then we wouldn't bother defining the any of the
     five.
=====

[TIP]
=====
* `std::move` doesn't actually move anything on its own.
* It is a wrapper for a `static_cast<T&&>`, where `T` is the type you pass to `std::move`.
* All the moving happens in the constructor we've just spoken about, and the assignment operator
  below.
* `std::move` is a trick to get the compiler to let us move an lvalue.
=====

==== Move assignment operators
* Similarly to copy assignment, move assignment is responsible for moving resources from an object A
  to a prexisting object B, after having released the resources that B holds.

.Self-assignment with the move constructor
[CAUTION]
=========
* The standard implies that self-assignment with a move assignment operator is unspecified.
   - It could clear out the object (same as xoring with itself), or
   - It could be a no-op (i.e. optimised out)
* If you want the former to happen, don't check for self-assignment: a correctly written move
  assignment operator will cause this to happen automatically.
* If you prefer the latter to happen, you cannot employ the copy-and-swap method used in the copy
  assignment operator.
* You must use the check-for-self method, like so:

[source,cpp]
------------
template <typename T>
record<T>& record<T>::operator=(record<T>&& r)
{
   if (this != &r)
   {
      delete[] resource_;
      data_ = std::move(r.data_);
      resource_ = r.resource_;
      r.resource_ = nullptr;
   }

   return *this;
}
------------
=========

* **The rule of five is an extension to the rule of three, requiring you to supply a user-defined
     move constructor, _and_ a user-defined move assignment operator.**
[WARNING]
=========
* Not everything is moveable (built-in types, stack-allocated arrays, etc.).
* Some things that can be moved can't be copied (e.g. `unique_ptr`).
   - These do not fall under the rule of three, but should still have user-defined move constructors
     and user-defined move assignment operators.
* Similarly to the rule of three, tools may help, but they probably won't. Be vigilant.
=========

=== The rule of zero
* Don't provide a custom copy/move constructor, or a custom copy/move assignment operator!
* If your type doesn't personally manage a resource, don't bother with _any_ of the five.
* The compiler will synthesise a perfectly working copy constructor, move constructor, copy
  assignment operator, move assignment operator, and destructor for you.
   - These will call the appropriate constructors for all of your members.
* The rule of zero often isn't applicable to library developers (which is why you need to write all
  five in the second assignment).
* Why is the rule of zero recommended?
   1. You don't need to write five functions -- less to write
   2. You don't need to write five _complex_ functions -- less to think about
   3. You don't need to _test_ five complex functions -- less to test
   4. Someone has already done the work... just elsewhere! Don't reinvent the wheel!
* Unless I'm implementing library code, I stick to the rule of zero.
* What about if you want something to be moveable, but not copyable? Check out this:

[source,cpp]
------------
template <typename T>
class record
{
public:
   record() = default;
   record(const T& t);

   record(const record&) = delete;
   record& operator=(const record&) = delete;
   ~record() = default;

   record(record&&) = default;
   record& operator=(record&&) = default;
private:
   std::vector<T> data_;
   resource_t* resource_;
};
------------

* The functions that are `= default` are still synthesised by the compiler.
* The functions that are `= delete` are not implemented.

=== Copy elision
* So, we've looked at both copy control and move semantics, or more formally known as RAII.
* We've learned about shallow (cheap) copies and deep (expensive) copies, and how moving _can_ be
  cheap for some types.
* "_Chris! Does this mean you've been lying to us this whole time? That we should be returning
  local variables via `std::move`?_" you might ask at this point.
* Do you mean like _this_ code, shown below?

[source,cpp]
------------
std::vector<int> make_school(const int children)
{
   auto crowd = std::vector<int>{};

   auto generator = std::mt19937{std::random_device{}()};
   auto distribute = std::uniform_int_distribution<>{12, 19};

   std::generate_n(std::back_insert_iterator<decltype(crowd)>{crowd}, children,
                   [&]{ return distribute(generator); });

   return std::move(crowd);
}
------------

* "Yes! That's exactly what I mean! Won't that force the compiler not to make a copy, thus making
  my code more efficient?"
* [big]*NO!*
* Did you write a test to check that it's more efficient?
   - If you did, and still came to that conclusion, you'd be lying.
* Do not, under any circumstances, return by wrapping your object in `std::move`.
* The compiler is allowed to perform an optimisation known as _copy elision_.
   - Under certain conditions, the compiler is allowed to eliminate the need for calling both the
     copy constructor and the move constructor.
* When these conditions aren't met, or if the compiler doesn't perform the optimisation, the
  compiler will automatically perform a move anyway.
* By adding `std::move`, you will:
   - At best, do nothing
   - At worst, trick the compiler into not doing the copy/move constructor elimination.
* This is one of the _very few_ hard and fast rules that I assert.

=== Passing by parameters revisited
* You might be wondering whether or not what the rules are regarding pass by rvalue reference, since
  there are rules for passing by value, passing by reference, and passing by reference-to-`const`.
* Since there's two types of reference, should we be writing:
   - one function that passes by reference-to-`const` for non-destructive reads, and
   - one function that passes by rvalue reference for destructive reads?
* If you think about that for long enough, you should conclude that you'll have a combinatorial
  number of functions to write, based on the number of parameters:
   - 1 parameter -> 2 functions
   - 2 parameters -> 4 functions
   - 3 parameters -> 8 functions
   - so on...
* You'll be relieved to hear that for most people, you _don't_ need to pass by rvalue reference,
  most of the time.
      ** You can probably get away without calling `std::move` on a regular basis.
      ** I've only rarely called `std::move` outside of a move constructor/assignment operator,
         because I rely on moving temporaries.
* Library writers need to be more aware of passing by rvalue reference, but only in certain sections
  of their code.
* Passing by value can invoke either the copy constructor or the move constructor based on the
  context.
* In 2009, people started getting excited about move semantics, and started pathologically passing
  by value much more often.
* You will probably make things much slower by passing by value (you can see tests in the video
  linked below).
   - So pass by reference-to-`const`, as normal.
* The last point applies to all functions except for constructors, and _only_ constructors.
* Only after performance testing that proves the following is _undoubtedly_ faster than passing by
  reference-to-`const`, should you consider the following:

[source,cpp]
------------
class film
{
public:
   film(std::string, std::string, std::vector<std::string>, const std::int64_t);
   const std::string& title() const;
private:
   std::string title_;
   std::string director_;
   std::vector<std::string> cast_;
   std::int64_t revenue_;
};

film::film(std::string title, std::string director, std::vector<std::string> cast, std::int64_t revenue);
   : title_{std::move(title)},
     director_{std::move(director)},
     cast_{std::move(cast)},
     revenue_{revenue}
{
}
------------

== {cpp}'s most vexing parse
* Pop quiz: does this code compile?
   - Why or why not?
   - If it does compile, what is its output?

[source,cpp]
------------
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>

int main()
{
   constexpr auto size  = 8;
   constexpr auto value = 20;
   std::vector<double> foo(size, value);
   std::copy(foo.cbegin(), foo.cend(),
             std::ostream_iterator<decltype(foo)::value_type>{std::cout, " "});

   std::cout << '\n';
}
------------

* Yes, it compiles!
* The output is the number 20, printed eight times, each print on a separate line.

[source,cpp]
--------
20 20 20 20 20 20 20 20 
--------

* How about this code?

[source,cpp]
------------
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>

int main()
{
   constexpr auto size = 8;
   constexpr auto value = 20;
   std::vector<double> foo(std::size_t(size), double(value));
   std::copy(foo.cbegin(), foo.cend(),
             std::ostream_iterator<decltype(foo)::value_type>{std::cout, " "});

   std::cout << '\n';
}
------------

* No, this code doesn't compile!
* What's the error?

[source,cpp]
-------------
cjdb: g++ -Wall -Wextra -Werror -pedantic -std=c++14 -o mvp mvp.cpp
mvp.cpp: In function ‘int main()’:
mvp.cpp:11:18: error: request for member ‘cbegin’ in ‘foo’, which is of non-class type ‘std::vector<double>(std::size_t, double) {aka std::vector<double>(long long unsigned int, double)}’
    std::copy(foo.cbegin(), foo.cend(),
                  ^
mvp.cpp:11:32: error: request for member ‘cend’ in ‘foo’, which is of non-class type ‘std::vector<double>(std::size_t, double) {aka std::vector<double>(long long unsigned int, double)}’
    std::copy(foo.cbegin(), foo.cend(),
                                ^
cc1plus: all warnings being treated as errors
-------------

* That's odd... foo was clearly defined in the second line of `main`...
   - There's a few more errors that have been omitted because they aren't relevant.
* The problem is with the line `std::vector<int> foo(std::size_t(size));`
   - We tried to convert `size` an unsigned integer type, because the previous program had a
     narrowing conversion.
   - We also tried to convert `value` to a floating-point number type, because the previous program
     had another narrowing conversion.
   - The problem is that based on {cpp}'s parsing rules, `foo` is a function declaration!
   - What about the `size_t(size)`, you ask?
   - That's a parameter of type `std::size_t`, and is named `size` in this declaration.
* This problem has been titled "{cpp}'s Most Vexing Parse" by Scott Meyers.
   - He's da real MVP!
* So, how do we stop MVP?
* Two ways, and you should already be employing the second way.
* The first way is to use list-initialisation (with `{}` instead of `()`):

[source,cpp]
------------
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>

int main()
{
   constexpr auto size = 8;
   constexpr auto value = 20;
   std::vector<double> foo{std::size_t(size), double(value)}; // notice the braces, not the parentheses
   std::copy(foo.cbegin(), foo.cend(),
             std::ostream_iterator<decltype(foo)::value_type>{std::cout, " "});

   std::cout << '\n';
}
------------

* Let's run the program:

[source,cpp]
--------
8 20 
--------

* The output isn't the same!
   - "Initializer-list constructors are favored over other constructors in list-initialization" --
     Working Draft for Standard C++.
   - This means that the vector takes two doubles, rather than a `size_t` and a `double`.

* The second way, which is preferable, is via `auto`:

[source,cpp]
------------
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>

int main()
{
   constexpr auto size = 8;
   constexpr auto value = 20;

   auto foo = std::vector<int>(std::size_t(size), double(value));
   std::copy(foo.cbegin(), foo.cend(),
             std::ostream_iterator<decltype(foo)::value_type>{std::cout, " "});

   std::cout << '\n';
}
------------

* That works, even though it "looks" like the previous one.

[source,cpp]
------------
20 20 20 20 20 20 20 20 
------------

* An even better solution is to choose your types correctly, and not requiring conversion.
* Prefer a combination of automatic type deduction _and_ list-initialisation.
   - That is, always put `auto` on the left-hand side (even for fundamental types).
   - On the right-hand side, choose based on whether you need list-initalisation or a constructor.
   - If it doesn't matter between the two, choose list-initialisation.
